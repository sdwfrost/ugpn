install.packages("diversitree")
install.packages("diversitree")
setwd("~/Projects/mers")
library(ape)
library(ggplot2)
library(ggtree)
library(magrittr)
library(phangorn)
library(phylobase)
library(adephylo)
library(phytools)
library(diversitree)
library(rcolgem)
library(bbmle)
x <- read.beast("MERS_SaudiArabia_aligned_combined.tree.txt")
tr <- x@phylo
host <- tr$tip.label %>% strsplit(.,"_") %>% lapply(.,"[",2) %>% unlist
dd <- data.frame(taxa=tr$tip.label,host=host)
g <- ggtree(x, right=TRUE) %<+% dd
g + theme_tree2() + geom_point(subset=.(isTip),aes(shape=host,color=host),size=4) + scale_x_continuous() + theme(panel.grid.major   = element_line(color="black", size=.2), panel.grid.minor   = element_line(color="grey", size=.2), panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())
assignStatesToNodes <- function(x){
x <- as(x,"phylo4")
# check tree is ultrametric, so we can use just one node to get maximum time
treedepth <- max(as.double(distRoot(x)))
# assign states to tips
labels <- attr(x,"label")
numtips <- nTips(x)
statedict <- list()
for(i in 1:numtips){
thislabel <- labels[i]
if(grepl("Human",as.character(thislabel))){
statedict[[as.character(i)]] <- "Y"
}else{
statedict[[as.character(i)]] <- "I"
}
}
# generate node indexes
nodIdx <- nTips(x) + 1
nodIdx <- nodIdx:(nodIdx + nNodes(x) - 1)
numnodes <- length(nodIdx)
dd <- listDD(x,nameBy="number")
# get ages of each node
alldepth <- nodeDepth(x)
nd <- alldepth[nodIdx]
o <- order(nd,decreasing=TRUE)
numjumps <- 0
jumptimes <- c()
for(i in 1:numnodes){
thisnode <- nodIdx[o[i]]
thisnodedesc <- children(x,thisnode)
thisnodedesc2 <- as.integer(thisnodedesc)
pstate1 <- statedict[[as.character(thisnodedesc[1])]]
pstate2 <- statedict[[as.character(thisnodedesc[2])]]
if(pstate1==pstate2){
statedict[[as.character(thisnode)]] <- pstate1
}
else{
statedict[[as.character(thisnode)]] <- "I"
numjumps <- numjumps+1
jumptimes <- c(jumptimes,treedepth-alldepth[thisnode])
}
}
jumptimes
}
tr.parsimony <- tr
tr.parsimony$node.label <- paste("Node",seq(1,length(tr$node.label)))
tr.parsimony.jumps <- assignStatesToNodes(tr.parsimony)
tr.parsimony
tr.parsimony <- tr
tr.parsimony
tr.parsimony$node.label <- paste("Node",seq(1,44))
tr.parsimony.jumps <- assignStatesToNodes(tr.parsimony)
check.tree <- function (tree, ultrametric = TRUE, bifurcating = TRUE, node.labels = FALSE)
{
if (!inherits(tree, "phylo"))
stop("'tree' must be a valid phylo tree")
#if (ultrametric && !is.ultrametric(tree))
#    stop("'tree' must be ultrametric")
if (any(tree$edge.length < 0))
stop("Negative branch lengths in tree")
if (bifurcating && (!is.binary.tree(tree) || any(tabulate(tree$edge[,
1]) == 1)))
stop("'tree must be bifurcating (no polytomies or unbranched nodes)'")
if (any(duplicated(tree$tip.label)))
stop("Tree contains duplicated tip labels")
if (node.labels) {
if (is.null(tree$node.label))
tree$node.label <- sprintf("nd%d", seq_len(tree$Nnode))
else if (any(duplicated(tree$node.label)))
stop("Tree contains duplicated node labels")
}
tree
}
assignInNamespace("check.tree",check.tree,ns="diversitree")
getML<-function(tr){
states<-as.integer(grepl("Human",tr$tip.label))
names(states)<-tr$tip.label
lik<-make.mk2(tr,states)
#Set q10 to 0 so transition can only occur in one direction
lik2<-constrain(lik, formulae = list(q10~0))
#Fit the model
fit.mk2 <- find.mle(lik2, c(0.5), root=ROOT.GIVEN, root.p=c(1,0),intermediates=T,keep.func=FALSE)
#Stochastic ancestral reconstruction gives an error:
#st.s <- asr.stoch(lik2,coef(fit.mk2))
#Setting the q01 to a very small number overcomes the problem.
lik3<-constrain(lik, formulae = list(q10~1E-12))
#Run stochastic mapping
st.s<-asr.stoch(lik3,coef(fit.mk2))
num.branches<-dim(tr$edge)[1]
num.nodes<-tr$Nnode
num.tips<-length(tr$tip)
num.branch.jumps<-0
branch.times<-array(NA,num.branches)
node.jumps<-array(NA,num.branches)
num.node.jumps<-0
node.time<-array(NA,num.branches)
for(j in 1:num.branches){
if(length(st.s$history[[j]][,1])==2){
num.branch.jumps<-num.branch.jumps+1
branch.times[j]<-tr$edge.length[j]-st.s$history[[j]][2,1]
node.jumps[j]<-tr$edge[j,1]
}
}
branch.times<-sort(na.omit(as.vector(branch.times)),decreasing=F)
#abline(v=branch.time,col=2)
num.node.jumps<-sum(!is.na(unique(node.jumps)))
max.time<-max(node.depth.edgelength(tr))
node.times<-sort(max.time-node.depth.edgelength(tr)[na.omit(as.vector(unique(node.jumps)))])
jumps.ML <- list(num.branch.jumps=num.branch.jumps,branch.times=branch.times,num.node.jumps=num.node.jumps,max.time=max.time,node.times=node.times,fit=fit.mk2)
return(jumps.ML)
}
tr.ml <- tr.parsimony
ntrees <- 100
tr.ml.jumps.list <- list()
for(i in 1:ntrees){
tr.ml.jumps <- getML(tr.ml)
tr.ml.jumps.list[[i]] <- tr.ml.jumps
}
## Add an alpha value to a colour
add.alpha <- function(col, alpha=1){
if(missing(col))
stop("Please provide a vector of colours.")
apply(sapply(col, col2rgb)/255, 2,
function(x)
rgb(x[1], x[2], x[3], alpha=alpha))
}
plot(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,ylim=c(0,15),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps")
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$node.times
lines(seq(1,length(j))~j,pch=16,col=add.alpha("gray",alpha=0.2),type="b")
}
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~j,pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
lines(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,type="b")
plot(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,ylim=c(0,15),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps")
#for(i in 1:ntrees){
#  j <- tr.ml.jumps.list[[i]]$node.times
#  lines(seq(1,length(j))~j,pch=16,col=add.alpha("gray",alpha=0.2),type="b")
#}
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~j,pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
lines(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,type="b")
png("jumps.png",width=8*300,height=5*300,res=300)
plot(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,ylim=c(0,15),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps")
#for(i in 1:ntrees){
#  j <- tr.ml.jumps.list[[i]]$node.times
#  lines(seq(1,length(j))~j,pch=16,col=add.alpha("gray",alpha=0.2),type="b")
#}
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~j,pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
lines(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,type="b")
dev.off()
svg("jumps.svg",width=8,height=5)
plot(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,ylim=c(0,15),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps")
#for(i in 1:ntrees){
#  j <- tr.ml.jumps.list[[i]]$node.times
#  lines(seq(1,length(j))~j,pch=16,col=add.alpha("gray",alpha=0.2),type="b")
#}
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~j,pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
lines(seq(1,length(tr.parsimony.jumps))~tr.parsimony.jumps,pch=16,type="b")
dev.off()
plot(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,ylim=c(0,15),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps")
#for(i in 1:ntrees){
#  j <- tr.ml.jumps.list[[i]]$node.times
#  lines(seq(1,length(j))~j,pch=16,col=add.alpha("gray",alpha=0.2),type="b")
#}
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~I(-j),pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
plot(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,ylim=c(-15,0),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps",axes=F)
axis(1)
plot(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,ylim=c(-15,0),xlim=c(0,max(distRoot(tr.ml))),type="n",xlab="Time since present",ylab="No. of jumps",axes=F)
axis(2)
plot(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,ylim=c(0,15),xlim=c(-max(distRoot(tr.ml)),0),type="n",xlab="Time since present",ylab="No. of jumps",axes=F)
axis(2)
plot(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,ylim=c(0,15),xlim=c(-max(distRoot(tr.ml)),0),type="n",xlab="Time since present",ylab="No. of jumps",axes=F)
axis(2,las=1)
axis(1,at=seq(-4,0,by=0.5),labels=rev(seq(0,4,by=0.5)))
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~I(-j),pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
lines(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,type="b")
svg("jumps.svg",width=8,height=5)
plot(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,ylim=c(0,15),xlim=c(-max(distRoot(tr.ml)),0),type="n",xlab="Time since present",ylab="No. of jumps",axes=F)
axis(2,las=1)
axis(1,at=seq(-4,0,by=0.5),labels=rev(seq(0,4,by=0.5)))
#for(i in 1:ntrees){
#  j <- tr.ml.jumps.list[[i]]$node.times
#  lines(seq(1,length(j))~j,pch=16,col=add.alpha("gray",alpha=0.2),type="b")
#}
for(i in 1:ntrees){
j <- tr.ml.jumps.list[[i]]$branch.times
lines(seq(1,length(j))~I(-j),pch=16,col=add.alpha("red",alpha=0.2),type="b")
}
lines(seq(1,length(tr.parsimony.jumps))~I(-tr.parsimony.jumps),pch=16,type="b")
dev.off()
setwd("~/Presentations/onehealth")
slidify("index.Rmd")
library(slidify)
slidify("index.Rmd")
publish(user = "sdwfrost", repo = "onehealth")
slidify("index.Rmd")
slidify("index.Rmd")
slidify("index.Rmd")
publish(user = "sdwfrost", repo = "onehealth")
slidify("index.Rmd")
publish(user = "sdwfrost", repo = "onehealth")
